<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holiday Magic - Ultimate Bright</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New_Roman&display=swap" rel="stylesheet">

    <style>
        :root {
            --c-bg: #000000;
            --c-gold: #ffeb3b; /* 亮金色 */
            --c-cream: #fffacd;
            --font-title: 'Cinzel', serif;
            --font-body: 'Times New Roman', serif;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--c-bg); overflow: hidden;
            font-family: var(--font-body); color: var(--c-gold);
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; transition: opacity 0.5s ease;
        }
        .ui-hidden { opacity: 0 !important; pointer-events: none !important; }

        h1 {
            font-family: var(--font-title); font-size: 56px; text-align: center; margin-top: 40px;
            /* 极高亮度的金色渐变 */
            background: linear-gradient(to bottom, #ffffff 10%, #ffeb3b 50%, #ffd700 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 25px rgba(255, 235, 59, 0.8));
            text-transform: uppercase; letter-spacing: 4px;
        }

        .upload-wrapper {
            position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: auto;
        }

        .glass-btn {
            background: rgba(30, 30, 30, 0.7); backdrop-filter: blur(10px);
            border: 1px solid var(--c-gold); color: var(--c-gold);
            padding: 12px 30px; font-family: var(--font-title); font-size: 14px;
            letter-spacing: 2px; cursor: pointer; transition: all 0.3s ease;
            text-transform: uppercase; outline: none;
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.3);
        }
        .glass-btn:hover { 
            background: rgba(255, 235, 59, 0.3); 
            box-shadow: 0 0 35px rgba(255, 235, 59, 0.6); 
            color: #fff;
        }

        .hint-text { display: block; margin-top: 15px; font-size: 12px; opacity: 0.9; color: var(--c-cream); }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s ease;
        }
        .spinner {
            width: 40px; height: 40px; border: 2px solid rgba(255, 235, 59, 0.2);
            border-top: 2px solid var(--c-gold); border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        .loader-text { font-family: var(--font-title); font-size: 14px; letter-spacing: 3px; color: var(--c-gold); }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #webcam-wrapper {
            position: fixed; bottom: 20px; right: 20px; width: 160px; height: 120px; z-index: 20;
            border: 1px solid rgba(255, 235, 59, 0.4); background: #000; border-radius: 8px;
            overflow: hidden; transform: scaleX(-1); opacity: 0; transition: opacity 0.5s;
        }
        #webcam-wrapper.active { opacity: 1; }
        #webcam { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        #cv-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; z-index: 2; }

        #status-pill {
            position: absolute; top: 20px; right: 20px;
            font-family: var(--font-title); font-size: 12px; color: var(--c-gold);
            border: 1px solid var(--c-gold); padding: 5px 12px; border-radius: 20px;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            opacity: 0.9; transition: color 0.3s;
        }
        .status-tree { color: #00ff00 !important; border-color: #00ff00 !important; }
        .status-scatter { color: #00ffff !important; border-color: #00ffff !important; }
        .status-focus { color: #ff0055 !important; border-color: #ff0055 !important; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>
    <div id="loader"><div class="spinner"></div><div class="loader-text">LIGHTING UP THE MAGIC...</div></div>
    <div id="ui-layer">
        <h1>Merry Christmas</h1>
        <div id="status-pill">WAITING...</div>
        <div class="upload-wrapper">
            <input type="file" id="file-input" accept="image/*" style="display: none;">
            <button class="glass-btn" onclick="document.getElementById('file-input').click()">ADD MEMORIES</button>
            <span class="hint-text">Press 'H' to Hide Controls</span>
        </div>
    </div>
    <div id="canvas-container"></div>
    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="cv-canvas" width="320" height="240"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // 颜色升级：全部调亮
        const CONFIG = {
            colors: { 
                gold: 0xffeb3b,   // 亮金色
                cream: 0xfffff0,  // 近乎白
                red: 0xff3333,    // 亮红
                green: 0x33aa33,  // 亮绿
                blue: 0x4444ff 
            },
            initialParticleCount: 1500, dustCount: 2500, camPos: new THREE.Vector3(0, 2, 50)
        };

        const STATE = {
            mode: 'TREE', targetPhoto: null, 
            handRotation: { x: 0, y: 0 }, 
            isHandDetected: false,
            gestureLockUntil: 0,
            isPinching: false
        };

        class TextureGenerator {
            static createCandyCane() {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // 纯白背景
                ctx.fillStyle = '#FFFFFF'; 
                ctx.fillRect(0, 0, 256, 256);
                
                // 鲜红条纹
                ctx.strokeStyle = '#FF0000'; 
                ctx.lineWidth = 60; 
                ctx.beginPath();
                for (let i = -256; i < 512; i += 100) {
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + 256, 256);
                }
                ctx.stroke();

                const tex = new THREE.CanvasTexture(canvas);
                tex.wrapS = THREE.RepeatWrapping;
                tex.wrapT = THREE.RepeatWrapping;
                tex.repeat.set(1, 1); 
                tex.colorSpace = THREE.SRGBColorSpace;
                tex.anisotropy = 16; 
                return tex;
            }
            
            static createDefaultPhoto() {
                const canvas = document.createElement('canvas');
                canvas.width = 512; canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, 512, 512);
                
                ctx.strokeStyle = '#ffeb3b'; 
                ctx.lineWidth = 20; 
                ctx.strokeRect(10, 10, 492, 492);

                ctx.fillStyle = '#ffeb3b'; 
                ctx.font = 'bold 70px serif';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('JOYEUX', 256, 210); 
                ctx.fillText('NOEL', 256, 290);
                
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                return tex;
            }
        }

        class Particle {
            constructor(type, mesh, id) {
                this.type = type; this.mesh = mesh; this.id = id;
                this.targetPos = new THREE.Vector3();
                this.mesh.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                
                // 新增：随机初始旋转，避免整齐划一
                this.mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

                // 新增：随机自转速度
                this.rotSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.03,
                    (Math.random() - 0.5) * 0.03,
                    (Math.random() - 0.5) * 0.03
                );

                this.flashIntensity = 0; this.isFlashing = false;
            }

            update(dt) {
                this.mesh.position.lerp(this.targetPos, 0.08);

                // 旋转逻辑升级
                // 1. 照片在Focus/Tree模式下有特殊朝向，不能随机旋转
                // 2. 其他粒子（糖果棒、方块、球）在任何模式下都应该保持慢速自转
                if (this.type === 'PHOTO') {
                    if (STATE.mode === 'FOCUS' && this.mesh === STATE.targetPhoto) {
                        this.mesh.rotation.set(0, 0, 0);
                    } else if (STATE.mode === 'TREE') {
                        const lookTarget = new THREE.Vector3(this.mesh.position.x * 2, this.mesh.position.y, this.mesh.position.z * 2);
                        this.mesh.lookAt(lookTarget);
                    } else {
                        // 背景里的照片
                        this.mesh.rotation.y += 0.005;
                    }
                } else {
                    // 糖果棒、方块、球体、尘埃：应用随机自转
                    this.mesh.rotation.x += this.rotSpeed.x;
                    this.mesh.rotation.y += this.rotSpeed.y;
                    this.mesh.rotation.z += this.rotSpeed.z;
                }

                let targetScale = 1;
                if (this.type === 'PHOTO') {
                    if (STATE.mode === 'FOCUS' && this.mesh === STATE.targetPhoto) targetScale = 4.5;
                    else if (STATE.mode === 'TREE') targetScale = 1.2;
                    this.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                }

                // 闪光逻辑升级：更亮、更白
                if (this.type === 'SPHERE') {
                    if (!this.isFlashing && Math.random() < 0.003) { 
                        this.isFlashing = true; this.flashIntensity = 1.0;
                    }
                    if (this.isFlashing) {
                        this.flashIntensity -= dt * 1.0;
                        if (this.flashIntensity <= 0) { this.flashIntensity = 0; this.isFlashing = false; }
                        
                        // 闪烁颜色：近乎白色的金光
                        this.mesh.material.emissive.setHex(0xffffee);
                        // 强度提升到 6.0，非常亮
                        this.mesh.material.emissiveIntensity = this.flashIntensity * 6.0;
                    }
                }
            }
        }

        class App {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.particles = [];
                this.clock = new THREE.Clock();
                this.handLandmarker = null;
                this.lastVideoTime = -1;
                this.cvCanvas = document.getElementById('cv-canvas');
                this.cvCtx = this.cvCanvas.getContext('2d');
                this.initThree();
                this.initContent();
                this.initCV();
                this.setupEvents();
                this.animate();
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000); 
                this.scene.fog = new THREE.FogExp2(0x000000, 0.01); // 雾更淡，更通透

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.copy(CONFIG.camPos);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.toneMapping = THREE.ReinhardToneMapping;
                this.renderer.toneMappingExposure = 1.5; // 进一步调高曝光
                this.container.appendChild(this.renderer.domElement);

                const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                this.scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

                // 灯光升级
                // 1. 环境光：0.6，很亮，保证阴影面也有细节
                const ambient = new THREE.AmbientLight(0xffffff, 0.6); 
                this.scene.add(ambient);

                // 2. 内部点光源：极亮
                const pLight = new THREE.PointLight(0xffaa00, 10, 100); 
                pLight.position.set(0, 5, 0); 
                this.scene.add(pLight);

                // 3. 顶部主光
                const spotGold = new THREE.SpotLight(CONFIG.colors.gold, 3000); 
                spotGold.position.set(20, 50, 20); 
                spotGold.angle = 0.6; 
                spotGold.penumbra = 0.5; 
                this.scene.add(spotGold);

                const spotBlue = new THREE.SpotLight(CONFIG.colors.blue, 400); 
                spotBlue.position.set(-20, 10, -20); 
                this.scene.add(spotBlue);

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.35, 0.5, 0.6)); // 阈值0.6，让更多物体发光

                this.mainGroup = new THREE.Group();
                this.scene.add(this.mainGroup);
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true; this.controls.enablePan = false;
            }

            initContent() {
                // 材质升级：高 Emissive 模拟内部发光
                const matGold = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.1, 
                    emissive: 0x554400, emissiveIntensity: 0.5 
                });
                const matGreen = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.green, metalness: 0.5, roughness: 0.3,
                    emissive: 0x002200, emissiveIntensity: 0.3
                });
                const matRed = new THREE.MeshPhysicalMaterial({ 
                    color: CONFIG.colors.red, metalness: 0.2, roughness: 0.1, clearcoat: 1.0,
                    emissive: 0x440000, emissiveIntensity: 0.4
                });
                const matDust = new THREE.MeshBasicMaterial({ color: 0xffffee }); // 亮白尘埃

                const geoBox = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const geoSphere = new THREE.SphereGeometry(0.3, 16, 16);
                
                const path = new THREE.CatmullRomCurve3([new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.5, 0), new THREE.Vector3(0.2, 0.8, 0), new THREE.Vector3(0.4, 0.6, 0)]);
                const geoCane = new THREE.TubeGeometry(path, 20, 0.08, 8, false);
                const matCane = new THREE.MeshStandardMaterial({ 
                    map: TextureGenerator.createCandyCane(), 
                    roughness: 0.2, metalness: 0.1,
                    emissive: 0x222222, emissiveIntensity: 0.2
                });
                
                const geoFrame = new THREE.BoxGeometry(1.2, 1.2, 0.1);
                
                // 默认照片
                const defaultTex = TextureGenerator.createDefaultPhoto();
                const matPhoto = new THREE.MeshBasicMaterial({ map: defaultTex, side: THREE.DoubleSide });
                const photoMesh = new THREE.Mesh(geoFrame, matGold.clone());
                const photoPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), matPhoto);
                photoPlane.position.z = 0.06; photoMesh.add(photoPlane);
                photoMesh.userData.isPhoto = true;
                this.mainGroup.add(photoMesh);
                this.particles.push(new Particle('PHOTO', photoMesh, 0));

                for (let i = 0; i < CONFIG.initialParticleCount; i++) {
                    let mesh, type; const r = Math.random();
                    if (r < 0.15) { type = 'CANE'; mesh = new THREE.Mesh(geoCane, matCane); }
                    else if (r < 0.45) { 
                        type = 'SPHERE'; 
                        const baseMat = r < 0.30 ? matRed : matGold;
                        mesh = new THREE.Mesh(geoSphere, baseMat.clone()); 
                    }
                    else { type = 'BOX'; mesh = new THREE.Mesh(geoBox, r < 0.8 ? matGreen : matGold); }
                    this.mainGroup.add(mesh); this.particles.push(new Particle(type, mesh, i + 1));
                }

                for(let i=0; i< CONFIG.dustCount; i++) {
                   const dust = new THREE.Mesh(new THREE.PlaneGeometry(0.05, 0.05), matDust);
                   dust.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                   this.mainGroup.add(dust); this.particles.push(new Particle('DUST', dust, i + 9999));
                }
                this.calculateTargets();
            }

            addPhotoToScene(texture) {
                const matGold = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.1,
                    emissive: 0x554400, emissiveIntensity: 0.5
                });
                const matPhoto = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 0.1), matGold);
                const photoPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), matPhoto);
                photoPlane.position.z = 0.06; mesh.add(photoPlane);
                mesh.userData.isPhoto = true;
                this.mainGroup.add(mesh);
                
                const p = new Particle('PHOTO', mesh, Date.now() % 10000);
                p.mesh.position.set(0, -2, 25); 
                p.targetPos.set(0, 2, 35); 
                this.particles.push(p); 
                
                STATE.targetPhoto = mesh;
                STATE.mode = 'FOCUS';
                STATE.gestureLockUntil = Date.now() + 2000;
                
                this.calculateTargets(); 
                
                document.getElementById('status-pill').innerText = "PHOTO ADDED";
                document.getElementById('status-pill').className = "status-focus";
            }

            calculateTargets() {
                const mode = STATE.mode; const time = Date.now() * 0.001;
                const totalMainParticles = this.particles.length - CONFIG.dustCount;

                this.particles.forEach((p, i) => {
                    if (mode === 'TREE') {
                        if (p.type === 'DUST') {
                            const angle = i * 0.1 + time; const r = 10 + Math.random() * 5;
                            p.targetPos.set(Math.cos(angle)*r, (i % 50) - 25, Math.sin(angle)*r);
                        } else {
                            let t = i / totalMainParticles;
                            let y = t * 45 - 22.5; 
                            let maxRadius = 14;

                            if (p.type === 'PHOTO') {
                                const hash = (p.id * 9301 + 49297) % 233280;
                                const randomH = hash / 233280; 
                                y = -12 + (randomH * 24); 
                                t = (y + 22.5) / 45;
                            }

                            const r = maxRadius * (1 - t); 
                            const angle = t * 60 * Math.PI + (i*0.1); 
                            p.targetPos.set(r * Math.cos(angle), y, r * Math.sin(angle));
                        }
                    } else if (mode === 'SCATTER') {
                        const radius = 8 + Math.random() * 12; const theta = Math.acos(THREE.MathUtils.randFloatSpread(2)); const phi = Math.random() * Math.PI * 2;
                        p.targetPos.setFromSphericalCoords(radius, phi, theta);
                    } else if (mode === 'FOCUS') {
                        if (p.type === 'PHOTO' && p.mesh === STATE.targetPhoto) { 
                            p.targetPos.set(0, 2, 35); 
                        } else { 
                            const r = 30 + Math.random() * 10; const angle = Math.random() * Math.PI * 2; 
                            p.targetPos.set(Math.cos(angle)*r, (Math.random()-0.5)*50, Math.sin(angle)*r); 
                        }
                    }
                });
            }

            async initCV() {
                try {
                    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                    this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO", numHands: 1
                    });
                    this.setupWebcam();
                } catch (e) { console.error("CV Error:", e); this.finalizeLoading(); }
            }

            setupWebcam() {
                const video = document.getElementById('webcam');
                const constraints = { video: { width: 320, height: 240, facingMode: "user" } };
                navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                    video.srcObject = stream;
                    video.play();
                    video.addEventListener('loadeddata', () => {
                        this.finalizeLoading();
                        document.getElementById('status-pill').innerText = "AI READY - SHOW HAND";
                        document.getElementById('webcam-wrapper').classList.add('active');
                    });
                }).catch(err => {
                    console.error("Camera denied:", err);
                    document.getElementById('status-pill').innerText = "CAMERA DENIED";
                    this.finalizeLoading();
                });
            }

            detectHands() {
                const video = document.getElementById('webcam');
                if (!this.handLandmarker || !video.srcObject) return;
                if (video.videoWidth === 0 || video.videoHeight === 0) return;
                if (video.currentTime !== this.lastVideoTime) {
                    this.lastVideoTime = video.currentTime;
                    try {
                        const results = this.handLandmarker.detectForVideo(video, performance.now());
                        this.cvCtx.clearRect(0, 0, this.cvCanvas.width, this.cvCanvas.height);
                        if (results.landmarks && results.landmarks.length > 0) {
                            this.drawDebug(results.landmarks[0]);
                            this.processGestures(results.landmarks[0]);
                        } else {
                            STATE.isHandDetected = false;
                            STATE.isPinching = false;
                        }
                    } catch (err) { }
                }
            }

            drawDebug(landmarks) {
                const ctx = this.cvCtx;
                ctx.save(); ctx.fillStyle = 'red'; ctx.strokeStyle = 'red'; ctx.lineWidth = 2;
                for(let p of landmarks) { ctx.beginPath(); ctx.arc(p.x * 320, p.y * 240, 3, 0, 2*Math.PI); ctx.fill(); }
                ctx.restore();
            }

            processGestures(landmarks) {
                if (Date.now() < STATE.gestureLockUntil) return;

                const wrist = landmarks[0];
                const middleMCP = landmarks[9];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const tips = [landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
                const handSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                if (handSize < 0.01) return; 

                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const normalizedPinch = pinchDist / handSize;

                let avgTipDist = 0; tips.forEach(t => avgTipDist += Math.hypot(t.x - wrist.x, t.y - wrist.y));
                avgTipDist /= 4;
                const normalizedTipDist = avgTipDist / handSize;

                const statusPill = document.getElementById('status-pill');

                if (normalizedPinch < 0.3) {
                    if (!STATE.isPinching) {
                        STATE.isPinching = true;
                        STATE.mode = 'FOCUS';
                        const photos = this.particles.filter(p => p.type === 'PHOTO');
                        if (photos.length > 0) {
                            let currentIndex = photos.findIndex(p => p.mesh === STATE.targetPhoto);
                            let nextIndex = (currentIndex + 1) % photos.length;
                            STATE.targetPhoto = photos[nextIndex].mesh;
                        }
                        this.calculateTargets();
                        statusPill.innerText = "GESTURE: PINCH (NEXT PHOTO)"; 
                        statusPill.className = "status-focus";
                    }
                } else {
                    STATE.isPinching = false;
                }

                if (normalizedTipDist < 0.9 && normalizedPinch > 0.4) { 
                    if (STATE.mode !== 'TREE') {
                        STATE.mode = 'TREE'; this.calculateTargets();
                        statusPill.innerText = "GESTURE: FIST (TREE)"; statusPill.className = "status-tree";
                    }
                } else if (normalizedTipDist > 1.3 && normalizedPinch > 0.4) {
                    if (STATE.mode !== 'SCATTER') {
                        STATE.mode = 'SCATTER'; this.calculateTargets();
                        statusPill.innerText = "GESTURE: OPEN (SCATTER)"; statusPill.className = "status-scatter";
                    }
                }
                const targetRotY = (0.5 - middleMCP.x) * 3.0; 
                const targetRotX = (middleMCP.y - 0.5) * 1.5;
                STATE.handRotation.x = targetRotX; STATE.handRotation.y = targetRotY;
                STATE.isHandDetected = true;
            }

            finalizeLoading() {
                const loader = document.getElementById('loader');
                if(loader) { loader.style.opacity = 0; setTimeout(() => loader.remove(), 800); }
            }

            setupEvents() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                });
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'h') document.getElementById('ui-layer').classList.toggle('ui-hidden');
                });
                document.getElementById('file-input').addEventListener('change', (e) => {
                    const f = e.target.files[0];
                    if (!f) return;
                    const reader = new FileReader();
                    reader.onload = (ev) => new THREE.TextureLoader().load(ev.target.result, (t) => {
                        t.colorSpace = THREE.SRGBColorSpace; this.addPhotoToScene(t);
                    });
                    reader.readAsDataURL(f);
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const dt = this.clock.getDelta();
                this.detectHands();
                this.particles.forEach(p => p.update(dt));
                
                if (STATE.mode === 'FOCUS') {
                    this.mainGroup.rotation.y += (0 - this.mainGroup.rotation.y) * 0.1;
                    this.mainGroup.rotation.x += (0 - this.mainGroup.rotation.x) * 0.1;
                } 
                else if (STATE.isHandDetected) {
                    this.mainGroup.rotation.y += (STATE.handRotation.y - this.mainGroup.rotation.y) * 0.1;
                    this.mainGroup.rotation.x += (STATE.handRotation.x - this.mainGroup.rotation.x) * 0.1;
                } else {
                    this.mainGroup.rotation.x += (0 - this.mainGroup.rotation.x) * 0.05;
                    if (STATE.mode === 'TREE') this.mainGroup.rotation.y += 0.002;
                }
                this.controls.update();
                this.composer.render();
            }
        }

        window.addEventListener('DOMContentLoaded', () => new App());
    </script>
</body>
</html>
